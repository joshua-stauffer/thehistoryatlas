


The History Atlas - overview and task tracker


______________________________________________________________________________



guideline #1:
    model the messiness of real life
guideline #2:
    create a beautiful story anyways


______________________________________________________________________________



PROGRESS            | ..... |
- React Client      |       |
- Apollo Server     | ..    |
- Read Model        | ..    |
- Write Model       | ..    |
- Event Store       | ...   |
- History Player    | ...   |
- NGINX             |       |
- RabbitMQ Broker   | ..    |
- Logger            |       |
- spaCy service     |       |
- geo service       |       |
- user service      |       |
- email service     |       |



______________________________________________________________________________



Current todo list
- ALL: create overview/api docs
- ALL: design/setup application wide logging
- ALL: create async rabbitmq template for python services
- ALL: compile stock starter input for testing/initialization
- ALL: run services with docker compose
- ALL: setup .env files for docker
- ALL: look into using poetry/creating packages?
- ALL: create standard config and broker files and move to inheriting them for specific use cases
- API: add redis queue
- API: add timeout to response queue
- API: break ReadModelQuery types into subtypes and combine them with a union
- CLIENT: cra & project setup
- CLIENT: redux
- CLIENT: apollo integration
- CLIENT: event feed
- CLIENT: quickview event window
- CLIENT: leaflet integration
- CLIENT: add drawing for cities and events
- EMAIL: create email service with sendgrid?
- GEO: create geo database
- GEO: add broker integration
- GEO: get kaggle cities
- GEO: find countries/states geo data
- NGINX: setup client & api behind nginx
- RABBITMQ: create config file, create two virtual hosts (one for testing/dev one for prod)
- READMODEL: add event count stat to double check sync with event store
- READMODEL: test replay history
- READMODEL: make sure all promises have catch statements
- READMODEL: upgrade database methods to actually use the database :)
- READMODEL: update types to fully use types.ts
                => especially look out for QueryPayload, which currently has two definitions
- READMODEL: fix typing for database's QueryMap
- SPACY: create NER parser
- SPACY: add broker integration
- SOFT DEPLOY: push to DO
- TEST: test scalability and load bearing
- USER: setup database
- USER: create login/validation/edit logic
- USER: add broker integration
- WRITEMODEL: create replay history method
- WRITEMODEL: setup alembic migrations?
- WRITEMODEL: add event count stat to double check synch with event store



______________________________________________________________________________



Questions
- EVENT STORE: should the publisher check for acks?
- EVENT STORE: how should we handle event store write failures?
                currently requeueing..
- EVENT STORE: how should we detect sqlalchemy write failures?
- ALL: I'm currently loading env variables once and passing them in a config 
        object. any reason to have each module load their own?
- HISTORY: how do i make sure that i don't send the next event until receiving
            an ack from the previous?
- HISTORY: at what point will i overflow the memory when i pull the entire
            database out at once, and what is a a better solution?
- WRITE MODEL: when i wrote the first version, i put the broker init into the
                run_forever method, so that i could provide for ways to 
                restart the broker on failure. should i do that everywhere else?
- READMODEL: should I create an event object which holds references to citations?
- READMODEL: what happens if the broker or History player crash while replaying?



______________________________________________________________________________



Bug list
- READMODEL: UnhandledPromiseRejectionWarning on startup (likely because some
              RabbitMQ message is getting passed accidentally to one of our
              message handlers?)
- READMODEL: poorly formed messages get rejected and requeued for infinity.
- API: queues don't autodelete when closed
- READMODEL:  queues don't autodelete when closed


______________________________________________________________________________




NOTES:
- ALL: let's use all caps as a convention for any type field in a json message.
        ...after hitting a bug because of a capitalization issue.
- WRITEMODEL: i could allow for async writes by having an instance check out
              an aggregate, then return it once it's done. As long as two
              instances don't work on the same aggregate, state is maintained.



______________________________________________________________________________



COMPLETED TODOS!
- (  done  ) API: create apollo server
- (  done  ) API: add broker integration
- (  done  ) EVENTSTORE: create persistent db
- (  done  ) EVENTSTORE: add tests to db
- (  done  ) HISTORY: add tests to db
- (  done  ) READMODEL: setup mongodb docker instance
- (  done  ) READMODEL: create sqlalchemy connection
- (  done  ) READMODEL: create rabbitmq broker interface
- (  done  ) READMODEL: create broker
- (  done  ) READMODEL: create main object
- (  done  ) READMODEL: expose database functionality
- (  done  ) READMODEL: finish replay history
- (  done  ) READMODEL: add event handlers
- (  done  ) READMODEL: add api request handlers
- (  done  ) WRITEMODEL: finish schema
- (  done  ) WRITEMODEL: add db for validation
- (  done  ) WRITEMODEL: add db client
- (  done  ) WRITEMODEL: complete validator/manager package
- (  done  ) WRITEMODEL: add tests to db
- (  done  ) WRITEMODEL: add config



______________________________________________________________________________
