

The History Atlas - a quick reference for public APIs across the project


______________________________________________________________________________
OVERVIEW
Communication across the History Atlas happens through messages passed using
the AMQP protocol. 

______________________________________________________________________________
RabbitMQ config details

  vhosts:
    /

  exchanges:
    main (topic)

  Generic message shape:
    type: string
    payload: {}

  Topics are organized as:
    <message_type>.<message_qualifier?>.<specific_message_recipient?>


______________________________________________________________________________
Message Types


  Command - JSON object capturing a users intent. It's collected in the client,
            assembled in the API, and processed in the WriteModel.
  valid types:
      PUBLISH_NEW_CITATION

..............................................................................



  Event - JSON object created from a validated Command. Considered emitted (and 
          provisional) upon creation in the Write Model, and become persisted 
          (and permanent) in the Event Store. Serve as the single source of
          truth across the application, and are generally accessible through
          the History Player service for building/rebuilding local state.
  valid types:
      CITATION_ADDED
      META_ADDED
      PERSON_ADDED
      PLACE_ADDED
      TIME_ADDED
      PERSON_TAGGED
      PLACE_TAGGED
      TIME_TAGGED

..............................................................................



  Query - JSON objects requesting information from another service - an 
          asynchronous RPC. These messages must include a correlation_id
          and a reply_to, and any responses should be directed to the
          queue reply_to and include the correlation_id.

        
______________________________________________________________________________
Topics and the message shapes they expect


    command.writemodel # change this to command?
      publishers:
        API
      consumers:
        WriteModel

      {
        type: PUBLISH_NEW_CITATION
        user: string
        timestamp: string
        payload: {
          text: string
          tags: {}[]
          meta: {}
        }
      }

EXAMPLES:
{"type": "PUBLISH_NEW_CITATION", "user": "joshki", "timestamp": "definitely right now", "payload": {"text": "oh hi there, some very interesting! sample! text!", "GUID": "fake-citation-3599", "tags": [], "meta": {}}}

// the following should fail if the first CITATION_PUBLISHED message is received first
{"type": "PUBLISH_NEW_CITATION", "user": "joshki", "timestamp": "whoknows", "payload": {"text": "a quote about someone important or not important doing something else important or not important someplace in the world at some point in time", "GUID": "fake-citation-3524",  "tags": [], "meta": {}}}

..............................................................................

    event.emitted
      publishers:
        WriteModel
      consumers:
        EventStore

      {
        type: EVENT_TRANSACTION
        user: string
        timestamp: string
        app_version: string
        payload: [
          <chron-ordered list of synthetic events>
        ]
      }

..............................................................................

    event.persisted
      publishers:
        EventStore
      consumers:
        ReadModel
        WriteModel
        GeoService?

      {
        type: CITATION_ADDED
        transaction_guid:   string
        app_version:        string
        user:               string
        timestamp:          string
        event_id:           int
        payload: {
          text:             string
          tags:             string[]
          meta:             string
        }
      }

      {
        type: META_ADDED
        transaction_guid:   string
        app_version:        string
        user:               string
        timestamp:          string
        event_id:           int
        payload: {
          meta_guid:        string
          citation_guid:    string
          author:           string
          publisher:        string
          title:            string
          pub_date?:        string
          page_num?:        int
          url?:             string
        }
      }

      {
        type: PERSON_ADDED
        transaction_guid:   string
        app_version:        string
        user:               string
        timestamp:          string
        event_id:           int
        payload: {
          citation_guid:    string
          person_guid:      string
          person_name:      string
          citation_start:   int
          citation_end:     int
        }
      }

      {
        type: PLACE_ADDED
        transaction_guid:   string
        app_version:        string
        user:               string
        timestamp:          string
        event_id:           int
        payload: {
          citation_guid:    string
          place_guid:       string
          place_name:       string
          citation_start:   int
          citation_end:     int
          latitude:         float
          longitude:        float
        }
      }

      {
        type: TIME_ADDED
        transaction_guid:   string
        app_version:        string
        user:               string
        timestamp:          string
        event_id:           int
        payload: {
          citation_guid:    string
          time_guid:        string
          time_name:        string
          citation_start:   int
          citation_end:     int         
        }
      }

      {
        type: PERSON_TAGGED
        transaction_guid:   string
        app_version:        string
        user:               string
        timestamp:          string
        event_id:           int
        payload: {
          citation_guid:    string
          person_guid:      string
          person_name:      string
          citation_start:   int
          citation_end:     int
        }
      }

      {
        type: PLACE_TAGGED
        transaction_guid:   string
        app_version:        string
        user:               string
        timestamp:          string
        event_id:           int
        payload: {
          citation_guid:    string
          place_guid:       string
          place_name:       string
          citation_start:   int
          citation_end:     int
        }
      }

      {
        type: TIME_TAGGED
        transaction_guid:   string
        app_version:        string
        user:               string
        timestamp:          string
        event_id:           int
        payload: {
          citation_guid:    string
          time_guid:        string
          time_name:        string
          citation_start:   int
          citation_end:     int         
        }
      }

  

EXAMPLES:
{"type": "CITATION_PUBLISHED", "payload": {"text": "a quote about someone important or not important doing something else important or not important someplace in the world at some point in time", "GUID": "fake-citation-3524"}}

..............................................................................

    event.replay.request
      publishers:
        ReadModel
        WriteModel
      consumers:
        History

        {
          type: REQUEST_HISTORY_REPLAY
          payload:{
            last_event_id: int
          }
        }
        =>

..............................................................................

    event.replay.*  
      writemodel | readmodel
      // note: each consumer should describe their own namespace and pass it to 
      // History when requesting a replay.
      publishers:
        History
      consumers:
        WriteModel
        ReadModel

        {
          type: <event_type>
          payload: {event}
        }
        ...
        {
          type: HISTORY_REPLAY_END
        }

..............................................................................

    event.replay.readmodel
      publishers:
        History
      consumers:

..............................................................................

    query.readmodel
      publishers:
        API
      consumers:
        ReadModel

        {
          type: GET_CITATIONS_BY_GUID
          payload: {
            citation_guids: str[]
          }
        }
        =>
        {
          type: CITATIONS_BY_GUID
          payload: {
            citations: 
              citation_guid: {
                text: str
                meta: {
                  title: str
                  author: str
                  publisher: str
                  other fields?
                }
                tags: {
                  star_char: int
                  stop_char: int
                  tag_type: enum PERSON | PLACE | TIME
                  tag_guid: str
                  name?: str          # TIME only
                  names?: str[]       # PLACE and PERSON
                  coords?: {          # PLACE only
                    latitude: float
                    longitude: float
                    geoshape?: str
                    }
                }[]
              }
            
              ||

              {
                error: citation guid does not exist
              }
            }
        }

        {
          type: GET_MANIFEST
          payload: {
            type: enum PERSON | PLACE | TIME,
            guid: str
          }
        }
        =>
        {
          type: MANIFEST
          payload: {
            guid: str
            citation_guids: str[]
          }
        }

        {
          type: GET_GUIDS_BY_NAME
          payload: {
            name: str
          }
        }
        =>
        {
          type: GUID_BY_NAME
          payload: {
            guids: str[]
          }
        }

..............................................................................
  # direct queues

    (api)
      // api creates its own queues on the fly and passes them to recipients
      // as the reply_to field in the AMQP message properties.
      publishers:
        any
      consumers:
        api

    {
      type: COMMAND_SUCCESS
    }
    {
      type: COMMAND_FAILED
      payload: {
        reason: string
        existing_event_guid: string
      }
    }